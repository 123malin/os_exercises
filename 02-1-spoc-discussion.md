lec 3 SPOC Discussion

提前准备

（请在周一上课前完成）

- 完成lec3的视频学习和提交对应的在线练习
- git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises  　in github repos。这样可以在本机上完成课堂练习。
- 仔细观察自己使用的计算机的启动过程和linux/ucore操作系统运行后的情况。搜索“80386　开机　启动”
- 了解控制流，异常控制流，函数调用,中断，异常(故障)，系统调用（陷阱）,切换，用户态（用户模式），内核态（内核模式）等基本概念。思考一下这些基本概念在linux, ucore, v9-cpu中的os*.c中是如何具体体现的。
- 思考为什么操作系统需要处理中断，异常，系统调用。这些是必须要有的吗？有哪些好处？有哪些不好的地方？
- 了解在PC机上有啥中断和异常。搜索“80386　中断　异常”
- 安装好ucore实验环境，能够编译运行lab8的answer
- 了解Linux和ucore有哪些系统调用。搜索“linux 系统调用", 搜索lab8中的syscall关键字相关内容。在linux下执行命令: man syscalls
- 会使用linux中的命令:objdump，nm，file, strace，man, 了解这些命令的用途。
- 了解如何OS是如何实现中断，异常，或系统调用的。会使用v9-cpu的dis,xc, xem命令（包括启动参数），分析v9-cpu中的os0.c, os2.c，了解与异常，中断，系统调用相关的os设计实现。阅读v9-cpu中的cpu.md文档，了解汇编指令的类型和含义等，了解v9-cpu的细节。
- 在piazza上就lec3学习中不理解问题进行提问。

第三讲 启动、中断、异常和系统调用-思考题

3.1 BIOS

1. 比较UEFI和BIOS的区别。
   {%s%}
   （1）UEFI用模块化、C语言风格的参数堆栈传递方式、动态链接的形式构建系统，它比BIOS更易于实现，容错和纠错特性也更强。
   （2）UEFI运行于32位或64位模式，突破了传统16位代码的寻址能力，达到处理器的最大寻址。
   （3）传统的BIOS启动由于MBR的限制，默认是无法引导超过2.1TB以上的硬盘的。而UEFI没有这个限制。
   （4）传统的BIOS引导安装的电脑，分区表的格式是MBR的。而UEFI引导安装的电脑，硬盘分区表是GPT格式的。
   （5）UEFI启动需要一个独立的分区，它将系统启动文件和操作系统本身隔离。
   {%ends%}
2. 描述PXE的大致启动流程。
   {%s%}
   （1）用户端电脑开机后，PXE Boot ROM先做自我检测，然后以广播形式发出一个请求FIND帧。
   （2）如果服务器收到个人电脑所送出的要求，就会送回 DHCP 回应，内容包括用户端的 IP 地址，预设通讯通道，及开机映像文件。
   （3）工作站收到服务器发回的响应后则会回应一个FRAME，以请求传送启动所需文件。
   （4）之后，将有更多的讯息在用户端与服务器之间作应答, 用以决定启动参数。用户端机器上的BootPROM由 TFTP 通讯协议从服务器下载开机映像档, 这个映像档就是软盘的映象文件。
   （5）工作站使用TFTP 协议接收启动文件后，将控制权转交启动块，引导操作系统，完成远程启动。
   {%ends%}

3.2 系统启动流程

1. 了解NTLDR的启动流程。
   {%s%}
   	NTLDR是一个隐藏的，只读的系统文件，位置在系统盘的根目录，用来装载操作系统。是windows nt 4.0/windows 2000/windows xp/windows server 2003的引导文件。启动流程如下：
   （1）开机后，运行POST程序，POST将检测系统的总内存以及其他硬件设备的状况，将磁盘第一个物理扇区加载到内存，加载硬盘主引导记录并运行，主引导记录会查找活动分区的起始位置。接着活动分区的引导扇区被加载并执行，最后从引导扇区加载并初始化NTLDR文件。
   （2）在初始引导加载器阶段中，NTLDR将把计算机的微处理器从实模式转换为32位平面内存模式，然后NTLDR执行适当的小型文件系统驱动程序。
   （3）当初始引导加载器阶段结束后将会进入操作系统选择阶段，如果计算机上安装了多个操作系统，由于NTLDR加载了正确的Boot.ini文件，那么在启动的时候将会出现要求选择操作系统的菜单，如果Boot.ini文件非法或不存在，那么NTLDR将会尝试从默认系统卷启动系统。
   （4）当操作系统选择阶段结束后将会进入硬件检测阶段，这时NTDETECT文件将会收集计算机中硬件信息列表，然后将列表返回到NTLDR。
   （5）硬件检测阶段结束后将会进入配置选择阶段，如果有多个硬件配置列表，那么将会出现配置文件选择菜单，如果只有一个则不会显示。
   （6）加载内核。
   {%ends%}
2. 了解GRUB的启动流程。
   {%s%}
   	机器加电启动后,BIOS开始自检，然后寻找MBR，执行直面的boot loader代码，Linux里面的boot loader通常是lilo或grub。grub的启动流程如下：
   （1）加载MBR，grub程序启动。
   （2）根据grub设定饿内核映像所在路径，系统读取内核映像，并进行解压缩操作。
   （3）内核解压后调用strat_kernel()函数启动一系列初始化函数并初始化各种设备。
   （4）启动Linux。
   {%ends%}
3. 比较NTLDR和GRUB的功能有差异。
   {%s%}
   	NTLDR只能装在硬盘，只能引导Windows；GRUB是第三方操作系统引导程序，可以装在硬盘、光盘、网络、U盘上，可以引导大多数操作系统，包括Windows、Linux、Dos等。
   {%ends%}
4. 了解u-boot的功能。
   {%s%}
   	U-Boot，全称 Universal Boot Loader，是遵循GPL条款的开放源码项目，作用是系统引导。主要功能列表如下：
   （1）系统引导支持NFS挂载、RAMDISK(压缩或非压缩)形式的根文件系统；支持NFS挂载、从FLASH中引导压缩或非压缩系统内核；
   （2）基本辅助功能强大的操作系统接口功能；可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤以Linux支持最为强劲；支持目标板环境参数多种存储方式，如FLASH、NVRAM、EEPROM；
   （3）CRC32校验可校验FLASH中内核、RAMDISK镜像文件是否完好；
   （4）设备驱动串口、SDRAM、FLASH、以太网、LCD、NVRAM、EEPROM、键盘、USB、PCMCIA、PCI、RTC等驱动支持；
   （5）上电自检功能SDRAM、FLASH大小自动检测；SDRAM故障检测；CPU型号；
   （6）特殊功能XIP内核引导；
   {%ends%}

3.3 中断、异常和系统调用比较

1. 什么是中断、异常和系统调用？
   {%s%}
   - 中断：来自硬件设备的处理请求。
   - 异常：非法指令或者其他原因导致当前指令执行失败。
   - 系统调用：应用程序主动向操作系统发出的服务请求。
   {%ends%}
2. 中断、异常和系统调用的处理流程有什么异同？
   {%s%}
   相同点：
   	都会保护现场、恢复现场；都可实现多级嵌套。
   不同点：
   	中断是异步响应的，异常是同步响应的，系统调用的相应方式既有异步也有同步。
   {%ends%}
3. 举例说明Linux中有哪些中断，哪些异常？
   {%s%}
   中断举例：
   （1）时钟中断（IRQ0，中断向量号32）
   （2）键盘中断（IRQ1，中断向量号33）
   （3）FPU异常中断（IRQ13，中断向量号44）
   异常举例：
   （1）除零错误（中断向量号0，处理程序：Divide_error）
   （2）设备不可用（中断向量号7，处理程序：Device_not_available）
   （3）页异常（中断向量号14，处理程序：Page_fault）
   {%ends%}
4. 以ucore lab8的answer为例，uCore的时钟中断处理流程。
   {%s%}
   （1）保存现场。
   （2）判断当前中断线上是否有中断处理程序，如有没有，进入下一步；如果有，压入栈中。
   （3）ticks自增。
   （4）恢复现场。
   {%ends%}
5. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)
   {%s%}
   	系统调用是内核提供的用于提供系统服务的一系列函数，这些函数在内核态实现，一般通过trap实现，是用户程序和内核交互的接口。
   	Linux共有上百个系统调用，分类如下：
   （1）进程控制
   	包括fork()、exit()、pause()等，用于对进程进行操作。
   （2）文件操作
   	包括open()、read()、chown()等，用于控制文件读写，以及对文件属性进行操作。
   （3）系统控制
   	包括outb()、reboot()、time()等，用于对系统进行操作。
   （4）内存管理
   	包括mmap()、getpagesize()、sync()等，用于对内存进行操作。
   （5）网络管理
   	包括getdomainname()、gethostid()等，用于对域名、主机等进行操作。
   （6）Socket控制
   	包括socket()、bind()、getsockname()等，用于进行socket操作。
   （7）用户管理
   	包括getuid()、setgid()、setgroups()等，用于对用户、组进行管理。
   （8）进程间通信
   	包括signal()、msgsnd()、pipe()等，用于进程间通信、同步互斥等操作。
   {%ends%}

      + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
      - 答案没有涉及上述两个要点；（0分）
      - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
      - 答案对上述两个要点进行了正确阐述（2分）
      - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）

1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
   {%s%}
   	uCore的系统调用有：exit、fork、wait、exec、yield、kill、getpid、putc、pgdir、gettime、lab6_set_priority、sleep、open、close、read、write、seek、fstat、fsync、getcwd、getdirentry、sys_dup共二十二个。
   	功能分类主要有：
   （1）进程控制：fork、exit、wait、exec、yield、kill、getpid、lab6_set_priority、sleep
   （2）系统控制：putc、pgdir、gettime
   （3）文件操作：open、close、read、write、seek、fstat、fsync、getcwd、getdirentry、sys_dup
   {%ends%}

      + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
      - 答案没有涉及上述两个要点；（0分）
      - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
      - 答案对上述两个要点进行了正确阐述（2分）
      - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）

3.4 linux系统调用分析

1. 通过分析lab1_ex0了解Linux应用的系统调用编写和含义。(w2l1)
   {%s%}
   objdump：显示二进制文件信息。
   nm：列出某些文件中的符号（包括函数和全局变量等）。
   file：探测给定文件的类型家。
   	操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的函数，通过一组称为系统调用（system call)的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序。
   {%ends%}

      + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
      - 答案没有涉及上述两个要点；（0分）
      - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
      - 答案对上述两个要点进行了正确阐述（2分）
      - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
     

1. 通过调试lab1_ex1了解Linux应用的系统调用执行过程。(w2l1)
   {%s%}
   	strace常用来跟踪进程执行时的系统调用和所接收的信号。
   	lab1_ex1只有一个printf函数，它的定义在文件printf.c中，它调用了putc()函数来输出，putc()调用write()函数输出，write()就是一个系统调用。在write函数里，首先将所对用的系统调用号存放在eax寄存器，然后通过中断指示处理器去做系统调用。退出中断后，堆栈切换，返回用户态，继续执行用户程序。
   {%ends%}

      + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
      - 答案没有涉及上述两个要点；（0分）
      - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
      - 答案对上述两个要点进行了正确阐述（2分）
      - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）

3.5 ucore系统调用分析

1. ucore的系统调用中参数传递代码分析。
   {%s%}
   	ucore的系统调用中参数数组包含5个元素，分别表示寄存器edx、ecx、ebx、edi、esi的值。这些值用来指示0x80号中断具体执行哪种系统调用。
   {%ends%}
2. 以getpid为例，分析ucore的系统调用中返回结果的传递代码。
   {%s%}
   	ucore中返回结果存放在寄存器eax中，getpid返回的是当前的进程id。
   {%ends%}
3. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
   {%s%}
   	操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的函数，通过一组称为系统调用（system call)的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的的内核函数完成所需的处理，将处理结果返回给应用程序。
   {%ends%}
4. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具strace的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
   {%s%}
   {%ends%}

3.6 请分析函数调用和系统调用的区别

1. 请从代码编写和执行过程来说明。
   {%s%}
   	一般函数调用即函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分，不管是java还是python的I/O最后都是通过read和write这样的系统调用来完成的。系统调用是用户程序和内核交互的接口。
   	系统调用：各个操作系统的系统调用时不同的，它调用系统内核的服务，是操作系统的一个入口点 ；在内核地址空间执行，需要切换到内核上下文环境然后再切换回来，开销大。
   {%ends%}
2. 说明int、iret、call和ret的指令准确功能
   {%s%}
   int：系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。在编程的时候，可以用int指令调用这些子程序。int n指令会取中断类型码，将标志寄存器、CS、EIP压入栈，跳转到中断处理程序。
   iret：当使用IRET指令返回到相同保护级别的任务时，IRET会从堆栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器。当使用IRET指令返回到一个不同的保护级别时，IRET不仅会从堆栈弹出以上内容，还会弹出堆栈段选择子及堆栈指针分别到SS与SP寄存器。
   call：首先是将返回地址（也就是call指令要执行时EIP的值）压入栈顶，然后是将程序跳转到当前调用的方法的起始地址。执行push和jump指令。
   ret：将栈顶的返回地址弹出到EIP，然后按照EIP此时指示的指令地址继续执行程序。
   {%ends%}

v9-cpu相关题目

---

提前准备

    cd YOUR v9-cpu DIR
    git pull 
    cd YOUR os_course_spoc_exercise DIR
    git pull 

v9-cpu系统调用实现

1. v9-cpu中os4.c的系统调用中参数传递代码分析。
   {%s%}
   {%ends%}
2. v9-cpu中os4.c的系统调用中返回结果的传递代码分析。
   {%s%}
   {%ends%}
3. 理解v9-cpu中os4.c的系统调用编写和含义。
   {%s%}
   {%ends%}
